<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      A Just-in-time Compiler In Rust &middot; HydroCode Design
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="/public/css/font-awesome.min.css">

  <script type="text/javascript" src="//use.typekit.net/phm0nvf.js"></script>
  <script type="text/javascript">try{Typekit.load();}catch(e){}</script>

  <!-- Google Analytics -->
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-34047874-1', 'auto');
  ga('send', 'pageview');

  </script>
  <!-- End Google Analytics -->

  <!-- Icons -->
  <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">-->
  <!--<link rel="shortcut icon" href="/public/favicon.ico">-->

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body class="">

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>I'm Daniel, a **Canadian** software engineer.<br /><br />I'm also working on <a href='http://titananalytics.com'>Titan Analytics.</a></p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Home</a>

    
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/about/">About</a>
        
      
    
      
    
      
    

    <a class="sidebar-nav-item" href="https://github.com/thehydroimpulse">GitHub</a>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2014. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <label for="sidebar-checkbox" class="sidebar-toggle"></label>

          <h3 class="masthead-title">
            <a href="/" title="Home">HydroCode Design</a>
            <small></small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">A Just-in-time Compiler In Rust</h1>
  <span class="post-date">17 Jan 2014</span>
  <p>Today, we&#39;re going to build a simple, very simple, JIT compiler in <a href="www.rust-lang.org">Rust</a>. Rust is a safe, concurrent, and practical language that aims at replacing C++ and become a better systems language. </p>

<p>Now, this is only the actual just-in-time compiler that we&#39;ll be implementing, not a language compiler, nor the encoding of machine instructions; the latter requires a lot of knowledge about the CPU instruction specification, such as x86.</p>

<p>If you&#39;d like to use a production grade JIT compiler, there&#39;s <a href="http://llvm.org/">LLVM</a> and <a href="http://www.gnu.org/software/libjit/">LibJit</a>, just to name a couple.</p>

<hr>

<p>What exactly is a <em><a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">just-in-time (JIT)</a></em> compiler? I think the following quote does a justice explanation.</p>

<blockquote>
<p>Whenever a program, while running, creates and runs some new executable code which was not part of the program when it was stored on disk, itâ€™s a JIT. - <a href="http://eli.thegreenplace.net/2013/10/17/getting-started-with-libjit-part-1/">Eli Bendersky</a></p>
</blockquote>

<hr>

<p>Before we get started, you&#39;ll need to get yourself a copy of the <a href="https://github.com/mozilla/rust">Rust compiler</a>. The current version, as of this writing &mdash; is 0.9. I&#39;ll be updating this article to be applicable to future versions. But, if I don&#39;t get to it in time, let me know.</p>

<p>Be aware that the Rust compiler takes a fairly long time to compile, mainly because it&#39;s a <a href="https://en.wikipedia.org/wiki/Bootstrapping_(compilers">bootstrapped compiler</a>. Thus, the compiler itself is written in Rust. Yeah, that might be confusing, but it makes the development of a language much more streamlined at the cost of more complexity. Currently, as far as I&#39;m aware, the Rust compiler must <a href="https://github.com/mozilla/rust/blob/master/Makefile.in#L13">compile itself 3 times</a>. It also has to compile it&#39;s dependencies, such as <a href="http://llvm.org/">LLVM</a>, <a href="https://github.com/joyent/libuv">libuv</a>, only once.</p>

<div class="message blue">
  <span><i class="fa fa-exclamation-circle"></i></span>
  <div>Also, make sure you have enough RAM (about 1.5GB) leftover, or dedicated for the compilation process of the Rust compiler. If you start paging/swapping, it'll compile <b>much</b> slower.</div>
</div>

<h2>Safety &amp; Interop</h2>

<p>Let&#39;s begin by talking about safety, considering it&#39;s one of Rust&#39;s principles to begin with. Creating a JIT compiler was one of the first things I tried implementing within Rust. Why? Well, I got straight down to the core system, and, thus, I was able to clearly see how Rust was at handling low-level programming, and C-interop.</p>

<p>Most of the constructs within a JIT compiler that handles any logic will be unsafe. Remember, I&#39;m talking about the JIT being the logic that handles the dynamic execution of code, machine code. If you&#39;d build a VM around this &mdash; or <em>a</em> JIT compiler &mdash; you could minimize the amount of unsafe code you&#39;d use. It would be much easier to prove that 1000 lines of code is correct, yourself, and let the compiler prove the rest; rather than having to prove mostly <em>everything</em> is correct yourself. This is what Rust offers. A way to minimize the amount of unsafe code you write and read.</p>

<p>The end result would ultimately be to expose <em>safe</em> interfaces to <strong>all</strong> logic. That&#39;s how we&#39;re going to work.</p>

<h3>Rust Modules</h3>

<p>Let&#39;s define the files, effectively modules, that we&#39;re going to write.</p>

<p>Here&#39;s our project&#39;s directory contents:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">src/
  main.rs
  raw.rs
  region.rs
  safe.rs
</code></pre></div>
<p>We&#39;ll be compiling all our examples with with <code>rustc</code>, Rust&#39;s compiler executable:</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash">mkdir -p bin <span class="o">&amp;&amp;</span> rustc -Z debug-info src/main.rs -o bin/jit
</code></pre></div>
<p>We simply create a new folder <code>bin</code> that will hold the compiled program. You can place this into a <code>Makefile</code> if you&#39;d like, for simplicity.</p>

<p><code>main.rs</code> will contain our program logic. This will contain our examples that will use our JIT compiler.</p>

<p><code>raw.rs</code> are C function interfaces. Libc is linked by default with Rust programs, so there are no extra efforts to include the library.</p>

<p><code>region.rs</code> will hold a Rust-idiomatic struct <code>MappedRegion</code> that contain some raw pointers, which are unsafe. We also define some implementations for a couple <a href="http://static.rust-lang.org/doc/master/tutorial.html#traits">Traits</a>.</p>

<p><code>safe.rs</code> will contain <em>safe</em> interfaces to native C functions.</p>

<h2></h2>

<p>Let&#39;s begin with the <code>raw.rs</code> module. We&#39;ll begin by including the <code>libc</code> module.</p>
<div class="highlight"><pre><code class="rust language-rust" data-lang="rust"><span class="c1">// src/raw.rs</span>
<span class="k">use</span> <span class="n">std</span><span class="o">::</span><span class="n">libc</span><span class="p">;</span>
</code></pre></div>
<p>Next, we&#39;ll want to define some external functions, C functions. These are <strong>all</strong> unsafe.</p>
<div class="highlight"><pre><code class="rust language-rust" data-lang="rust"><span class="c1">// src/raw.rs</span>
<span class="k">use</span> <span class="n">std</span><span class="o">::</span><span class="n">libc</span><span class="p">;</span>

<span class="k">extern</span> <span class="p">{}</span>
</code></pre></div>
<p>You don&#39;t <em>need</em> to understand the next function interfaces. They&#39;re interfaces to libc functions, such as <code>mmap</code>, <code>memcpy</code>, etc...</p>
<div class="highlight"><pre><code class="rust language-rust" data-lang="rust"><span class="c1">// src/raw.rs</span>
<span class="k">use</span> <span class="n">std</span><span class="o">::</span><span class="n">libc</span><span class="p">;</span>

<span class="k">extern</span> <span class="p">{</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">mmap</span><span class="p">(</span>
        <span class="n">addr</span> <span class="o">:</span> <span class="o">*</span><span class="n">libc</span><span class="o">::</span><span class="n">c_char</span><span class="p">,</span>
        <span class="n">length</span> <span class="o">:</span> <span class="n">libc</span><span class="o">::</span><span class="n">size_t</span><span class="p">,</span>
        <span class="n">prot</span> <span class="o">:</span> <span class="n">libc</span><span class="o">::</span><span class="n">c_int</span><span class="p">,</span>
        <span class="n">flags</span>  <span class="o">:</span> <span class="n">libc</span><span class="o">::</span><span class="n">c_int</span><span class="p">,</span>
        <span class="n">fd</span>   <span class="o">:</span> <span class="n">libc</span><span class="o">::</span><span class="n">c_int</span><span class="p">,</span>
        <span class="n">offset</span> <span class="o">:</span> <span class="n">libc</span><span class="o">::</span><span class="n">off_t</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="o">*</span><span class="k">u8</span><span class="p">;</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">munmap</span><span class="p">(</span>
        <span class="n">addr</span> <span class="o">:</span> <span class="o">*</span><span class="k">u8</span><span class="p">,</span>
        <span class="n">length</span> <span class="o">:</span> <span class="n">libc</span><span class="o">::</span><span class="n">size_t</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">libc</span><span class="o">::</span><span class="n">c_int</span><span class="p">;</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">mprotect</span><span class="p">(</span>
        <span class="n">addr</span><span class="o">:</span> <span class="o">*</span><span class="n">libc</span><span class="o">::</span><span class="n">c_void</span><span class="p">,</span>
        <span class="n">length</span><span class="o">:</span> <span class="n">libc</span><span class="o">::</span><span class="n">size_t</span><span class="p">,</span>
        <span class="n">prot</span><span class="o">:</span> <span class="n">libc</span><span class="o">::</span><span class="n">c_int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">libc</span><span class="o">::</span><span class="n">c_int</span><span class="p">;</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">memcpy</span><span class="p">(</span>
        <span class="n">dest</span><span class="o">:</span> <span class="o">*</span><span class="n">libc</span><span class="o">::</span><span class="n">c_void</span><span class="p">,</span>
        <span class="n">src</span><span class="o">:</span> <span class="o">*</span><span class="n">libc</span><span class="o">::</span><span class="n">c_void</span><span class="p">,</span>
        <span class="n">n</span><span class="o">:</span> <span class="n">libc</span><span class="o">::</span><span class="n">size_t</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="o">*</span><span class="n">libc</span><span class="o">::</span><span class="n">c_void</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="message blue">
  <span><i class="fa fa-exclamation-circle"></i></span>
  <div>Tip: A <b><code>*</code></b> defines a raw pointer. This is equivalent to <code>const T*</code> in C. <code>*mut T</code> is equivalent to <code>T*</code> &mdash; a normal C pointer.</div>
</div>

<p>We don&#39;t need to define the actual contents of these functions, because they will be included in the compiled binary by linking with libc.</p>

<p>Next, we&#39;ll also include some flags that interop with these functions.</p>
<div class="highlight"><pre><code class="rust language-rust" data-lang="rust"><span class="c1">// src/raw.rs</span>
<span class="k">use</span> <span class="n">std</span><span class="o">::</span><span class="n">libc</span><span class="p">;</span>

<span class="k">extern</span> <span class="p">{...}</span>

<span class="k">pub</span> <span class="k">static</span> <span class="n">PROT_NONE</span>   <span class="o">:</span> <span class="n">libc</span><span class="o">::</span><span class="n">c_int</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
<span class="k">pub</span> <span class="k">static</span> <span class="n">PROT_READ</span>   <span class="o">:</span> <span class="n">libc</span><span class="o">::</span><span class="n">c_int</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
<span class="k">pub</span> <span class="k">static</span> <span class="n">PROT_WRITE</span>  <span class="o">:</span> <span class="n">libc</span><span class="o">::</span><span class="n">c_int</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">;</span>
<span class="k">pub</span> <span class="k">static</span> <span class="n">PROT_EXEC</span>   <span class="o">:</span> <span class="n">libc</span><span class="o">::</span><span class="n">c_int</span> <span class="o">=</span> <span class="mh">0x4</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">static</span> <span class="n">MAP_SHARED</span>  <span class="o">:</span> <span class="n">libc</span><span class="o">::</span><span class="n">c_int</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
<span class="k">pub</span> <span class="k">static</span> <span class="n">MAP_PRIVATE</span> <span class="o">:</span> <span class="n">libc</span><span class="o">::</span><span class="n">c_int</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">;</span>
</code></pre></div>
<hr>

<p>Awesome, we&#39;re now done with the <code>src/raw.rs</code> module. As you can see, it&#39;s dead simple to interop with C code.</p>

<p>Because Rust is trying to provide a way to build <strong>safer</strong> software, we need to take advantage of this. Thus, we want to wrap the main portion of the state in a <em>safe</em> struct.</p>

<p>But, before we get into that, let&#39;s go through how we can execute machine code dynamically.</p>

<h2>Execution</h2>

<p>The first portion we need is to store our instructions somewhere in memory. Ok, so how about malloc? While malloc works on traditional data, we have some very specific requirements &mdash; them being that we need to control the memory&#39;s protection flags, and malloc doesn&#39;t give us that ability.</p>

<p>Mmap is exactly what we need. We need to create a new memory mapped region with some custom protection. Initially, we only need to read and write to the region. But, we&#39;ll need to change the protection to turn off writing <em>then</em> enable executation. By default, you cannot try and execute normal malloced memory. Well, you can try, but the program will blow up because of security reasons. Having a memory region that is <em>both</em> writable <strong>and</strong> executable is dangerously insecure. That&#39;s why we need to do it in steps.</p>

<ul>
<li>Allocate a new memory region of the size we need.</li>
<li>Make the region readable <strong>and</strong> writable.</li>
<li>Commit our instructions to that region.</li>
<li>Make it read-only and executable.</li>
</ul>

<hr>

<p>Let&#39;s get to starting <code>src/region.rs</code>. When we create a new memory region with <code>mmap</code>, we&#39;ll receive a pointer; which points to the beginning of the new memory block. This isn&#39;t safe, so we&#39;ll abstract it around safer constructs.</p>
<div class="highlight"><pre><code class="rust language-rust" data-lang="rust"><span class="c1">// src/region.rs</span>
<span class="k">use</span> <span class="n">std</span><span class="o">::</span><span class="n">os</span><span class="p">;</span>
<span class="k">use</span> <span class="n">std</span><span class="p">;</span>

<span class="k">mod</span> <span class="n">raw</span><span class="p">;</span>
</code></pre></div>
<p>Let&#39;s include the specific modules we need from the standard library, then define a local module we need to use &mdash; our raw module containing the C interfaces/prototypes.</p>
<div class="highlight"><pre><code class="rust language-rust" data-lang="rust"><span class="c1">// src/region.rs</span>
<span class="k">use</span> <span class="n">std</span><span class="o">::</span><span class="n">os</span><span class="p">;</span>
<span class="k">use</span> <span class="n">std</span><span class="p">;</span>

<span class="k">mod</span> <span class="n">raw</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">MappedRegion</span> <span class="p">{</span>
    <span class="n">addr</span><span class="o">:</span> <span class="o">*</span><span class="k">u8</span><span class="p">,</span>
    <span class="n">len</span><span class="o">:</span> <span class="k">u64</span>
<span class="p">}</span>
</code></pre></div>
<p>We are defining a new struct that wraps the dirty, raw pointer; and holds the length of the memory region.</p>

<p>The following implementations of Traits are for printing and memory deallocation, respectively.</p>

<div class="highlight"><pre><code class="rust"><span class="c1">// src/region.rs</span>
<span class="p">...</span>

<span class="k">impl</span> <span class="n">std</span><span class="o">::</span><span class="n">fmt</span><span class="o">::</span><span class="n">Default</span> <span class="k">for</span> <span class="n">MappedRegion</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">fmt</span><span class="p">(</span><span class="n">value</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">MappedRegion</span><span class="p">,</span> <span class="n">f</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">std</span><span class="o">::</span><span class="n">fmt</span><span class="o">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;MappedRegion</span><span class="se">\\</span><span class="s">{ {}, {}</span><span class="se">\\</span><span class="s">}&quot;</span><span class="p">,</span> 
          <span class="n">value</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">value</span><span class="p">.</span><span class="n">len</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<div class="highlight"><pre><code class="rust"><span class="c1">// src.region.rs</span>
<span class="p">...</span>

<span class="k">impl</span> <span class="n">Drop</span> <span class="k">for</span> <span class="n">MappedRegion</span> <span class="p">{</span>
    <span class="cp">#[inline(never)]</span>
    <span class="k">fn</span> <span class="n">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">raw</span><span class="o">::</span><span class="n">munmap</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="p">{</span>
                <span class="k">fail</span><span class="o">!</span><span class="p">(</span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;munmap({}, {}): {}&quot;</span><span class="p">,</span> 
                  <span class="n">self</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span>
                  <span class="n">self</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> 
                  <span class="n">os</span><span class="o">::</span><span class="n">last_os_error</span><span class="p">()</span>
                <span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>I&#39;m not going to go into much detail on the <code>Drop</code> trait, but this destructor will be called whenever the <em>owner</em> of the <code>MappedRegion</code> instance has gone out of scope.</p>

<hr>

<p>As with the Rust model of providing <em>safe</em> interfaces, we need to define friendlier functions than the raw C functions.</p>

<p>Let&#39;s create our <code>safe.rs</code> module.</p>

<div class="highlight"><pre><code class="rust"><span class="c1">// src/safe.rs</span>
<span class="k">use</span> <span class="n">region</span><span class="o">::</span><span class="n">MappedRegion</span><span class="p">;</span>
<span class="k">use</span> <span class="n">std</span><span class="o">::</span><span class="n">libc</span><span class="o">::</span><span class="p">{</span><span class="n">c_char</span><span class="p">,</span> <span class="n">size_t</span><span class="p">,</span> <span class="n">c_void</span><span class="p">};</span>
<span class="k">use</span> <span class="n">std</span><span class="o">::</span><span class="n">libc</span><span class="p">;</span>
<span class="k">use</span> <span class="n">std</span><span class="o">::</span><span class="n">os</span><span class="p">;</span>

<span class="k">mod</span> <span class="n">raw</span><span class="p">;</span>
<span class="k">mod</span> <span class="n">region</span><span class="p">;</span>
</code></pre></div>

<p>We&#39;ll start off by including some modules.</p>

<div class="highlight"><pre><code class="rust"><span class="c1">// src/safe.rs</span>
<span class="p">...</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">mmap</span><span class="p">(</span><span class="n">size</span><span class="o">:</span> <span class="k">u64</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="o">&lt;~</span><span class="n">MappedRegion</span><span class="p">,</span> <span class="o">~</span><span class="k">str</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">raw</span><span class="o">::</span><span class="n">mmap</span><span class="p">(</span>
            <span class="m">0</span> <span class="k">as</span> <span class="o">*</span><span class="n">libc</span><span class="o">::</span><span class="n">c_char</span><span class="p">,</span>
            <span class="n">size</span><span class="p">,</span>
            <span class="n">libc</span><span class="o">::</span><span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">libc</span><span class="o">::</span><span class="n">PROT_WRITE</span><span class="p">,</span>
            <span class="n">libc</span><span class="o">::</span><span class="n">MAP_PRIVATE</span> <span class="o">|</span> <span class="n">libc</span><span class="o">::</span><span class="n">MAP_ANON</span><span class="p">,</span>
            <span class="o">-</span><span class="m">1</span><span class="p">,</span>
            <span class="m">0</span>
        <span class="p">);</span>

        <span class="k">if</span> <span class="n">buf</span> <span class="o">==</span> <span class="o">-</span><span class="m">1</span> <span class="k">as</span> <span class="o">*</span><span class="k">u8</span> <span class="p">{</span>
          <span class="n">Err</span><span class="p">(</span><span class="n">os</span><span class="o">::</span><span class="n">last_os_error</span><span class="p">())</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">Ok</span><span class="p">(</span><span class="o">~</span><span class="n">MappedRegion</span><span class="p">{</span> <span class="n">addr</span><span class="o">:</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="o">:</span> <span class="n">size</span> <span class="p">})</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>Now, we defined a <em>safe</em> version of mmap. Thus, we don&#39;t accept unsafe inputs or outputs &mdash; no null points allowed.</p>

<div class="highlight"><pre><code class="rust"><span class="n">Result</span><span class="o">&lt;~</span><span class="n">MappedRegion</span><span class="p">,</span> <span class="o">~</span><span class="k">str</span><span class="o">&gt;</span>
</code></pre></div>

<p><code>Result</code> is one of Rust&#39;s types that provide safer and more expression code. <code>Result</code> includes two cases: Ok, and Err. This allows us to mattern match accordingly.</p>

<div class="highlight"><pre><code class="rust"><span class="c1">// example</span>
<span class="k">let</span> <span class="n">region</span> <span class="o">=</span> <span class="k">match</span> <span class="n">mmap</span><span class="p">(</span><span class="m">1024</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Ok</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">r</span><span class="p">,</span>
  <span class="n">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">fail</span><span class="o">!</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
<span class="p">};</span>
</code></pre></div>

<hr>

<p>We also return an owned pointer of <code>MappedRegion</code> if the function succeeded. We could&#39;ve returned the instance by value, but we&#39;ll need to pass this around to multiple functions, so we want to reduce copying.</p>

<hr>

<div class="highlight"><pre><code class="rust"><span class="n">libc</span><span class="o">::</span><span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">libc</span><span class="o">::</span><span class="n">PROT_WRITE</span>
</code></pre></div>

<p>These flags are important. They define what protection/permissions the memory region has. We can now read and write to the memory region.</p>

<p>Remember that the contents of this safe function is wrapped within an <code>unsafe</code> block. This is needed to interop with naked, unsafe code.</p>

<div class="message blue"><span><i class="fa fa-exclamation-circle"></i></span><div>Remember, it's much easier to understand and prove the correctness of one-thousand lines of completely unsafe code &mdash; which can be reasoned about &mdash; rather than hundreds of thousands of possibly unsafe, or even completely unsafe lines of code &mdash; that cannot be reasoned about.</div></div>

<hr>

<p>We can now create a new memory mapped region using safe interfaces. But, the memory doesn&#39;t have anything written to it yet. We&#39;ll use the <code>memcpy</code> function to copy the machine instructions to the memory region. Let&#39;s write a safe interface around the native function.</p>
<div class="highlight"><pre><code class="rust language-rust" data-lang="rust"><span class="c1">// src/safe.rs</span>
<span class="p">...</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">memcpy</span><span class="p">(</span><span class="n">region</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">MappedRegion</span><span class="p">,</span> <span class="n">contents</span><span class="o">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="k">u8</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="n">raw</span><span class="o">::</span><span class="n">memcpy</span><span class="p">(</span>
            <span class="n">region</span><span class="p">.</span><span class="n">addr</span> <span class="k">as</span> <span class="o">*</span> <span class="n">c_void</span><span class="p">,</span>
            <span class="n">contents</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">()</span> <span class="k">as</span> <span class="o">*</span><span class="n">c_void</span><span class="p">,</span>
            <span class="n">region</span><span class="p">.</span><span class="n">len</span> <span class="k">as</span> <span class="n">size_t</span><span class="p">);</span>
        <span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">contents</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">()),</span> <span class="o">*</span><span class="n">region</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<hr>

<p>We&#39;ll take a reference, or borrow a pointer to a <code>MappedRegion</code>.</p>
<div class="highlight"><pre><code class="rust language-rust" data-lang="rust"><span class="n">region</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">MappedRegion</span>
</code></pre></div>
<p>Pass a reference, or a borrowed pointer to a vector of <code>u8</code>s.</p>
<div class="highlight"><pre><code class="rust language-rust" data-lang="rust"><span class="n">contents</span><span class="o">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="k">u8</span><span class="p">]</span>
</code></pre></div>
<p>Again, we operate within an <code>unsafe</code> block. <code>memcpy</code> is practically like in C.</p>

<hr>
<div class="highlight"><pre><code class="rust language-rust" data-lang="rust"><span class="c1">// src/safe.rs</span>
<span class="p">...</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">mprotect</span><span class="p">(</span><span class="n">region</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">MappedRegion</span><span class="p">,</span> <span class="n">contents</span><span class="o">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="k">u8</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">raw</span><span class="o">::</span><span class="n">mprotect</span><span class="p">(</span>
            <span class="n">region</span><span class="p">.</span><span class="n">addr</span> <span class="k">as</span> <span class="o">*</span><span class="n">libc</span><span class="o">::</span><span class="n">c_void</span><span class="p">,</span>
            <span class="n">contents</span><span class="p">.</span><span class="n">len</span><span class="p">()</span> <span class="k">as</span> <span class="n">libc</span><span class="o">::</span><span class="n">size_t</span><span class="p">,</span>
            <span class="n">libc</span><span class="o">::</span><span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">libc</span><span class="o">::</span><span class="n">PROT_EXEC</span>
        <span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="m">1</span> <span class="p">{</span>
            <span class="k">fail</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;err: mprotect failed to protect </span>
<span class="s">              the memory region.&quot;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>The last function we need to define, takes the same arguments as <code>memcpy</code>. This is how we transform the memory region to be read-only and executable, after we write to it.</p>

<hr>

<p>Now we have <code>src/safe.rs</code>, <code>src/raw.rs</code>, and <code>src/region.rs</code> completed. We can now put these pieces together to make a functional JIT compiler.</p>

<p>Let&#39;s move onto our <code>src/main.rs</code> file.</p>

<p>We&#39;ll start by defining our crate:</p>
<div class="highlight"><pre><code class="rust language-rust" data-lang="rust"><span class="c1">// src/main.rs</span>
<span class="cp">#[crate_id = </span><span class="s">&quot;jiter#0.0.1&quot;</span><span class="cp">];</span>
<span class="cp">#[desc = </span><span class="s">&quot;Jiter&quot;</span><span class="cp">];</span>
<span class="cp">#[crate_type = </span><span class="s">&quot;bin&quot;</span><span class="cp">];</span>
<span class="cp">#[license = </span><span class="s">&quot;MIT&quot;</span><span class="cp">];</span>
</code></pre></div>
<p>Include some modules we&#39;ll need:</p>
<div class="highlight"><pre><code class="rust language-rust" data-lang="rust"><span class="c1">// src/main.rs</span>
<span class="p">...</span>
<span class="k">use</span> <span class="n">std</span><span class="o">::</span><span class="n">cast</span><span class="p">;</span>
<span class="k">use</span> <span class="n">region</span><span class="o">::</span><span class="n">MappedRegion</span><span class="p">;</span>
</code></pre></div>
<p>Include some local modules:</p>
<div class="highlight"><pre><code class="rust language-rust" data-lang="rust"><span class="c1">// src/main.rs</span>
<span class="p">...</span>
<span class="k">mod</span> <span class="n">raw</span><span class="p">;</span>
<span class="k">mod</span> <span class="n">region</span><span class="p">;</span>
<span class="k">mod</span> <span class="n">safe</span><span class="p">;</span>
</code></pre></div>
<p>Before we go any further, let&#39;s go through the machine code we&#39;ll be generating. We&#39;re defining a function, because all JIT code needs to be wrapped in some sort of function, which can be called; that takes a single integer as it&#39;s only input, adds four to that integer, then returns that value. We&#39;ll be using the standard cdecl calling convention.</p>
<div class="highlight"><pre><code class="asm language-asm" data-lang="asm"><span class="nf">mov</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="nv">%rax</span>
<span class="nf">add</span> <span class="no">$4</span><span class="p">,</span> <span class="nv">%rax</span>
<span class="nf">ret</span>
</code></pre></div>
<p>Which is compiled/encoded to:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">0x48 0x89 0xf8       // mov %rdi, %rax
0x48 0x83 0xc0 0x04  // add $4, %rax
0xc3                 // ret
</code></pre></div>
<p>We can express the code using a vector within Rust.</p>
<div class="highlight"><pre><code class="rust language-rust" data-lang="rust"><span class="k">let</span> <span class="n">code</span> <span class="o">=</span> <span class="p">[</span>
  <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x89</span><span class="p">,</span> <span class="mh">0xf8</span><span class="p">,</span>       <span class="c1">// mov %rdi, %rax</span>
  <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x83</span><span class="p">,</span> <span class="mh">0xc0</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="c1">// add $4, %rax</span>
  <span class="mh">0xc3</span>                    <span class="c1">// ret</span>
<span class="p">];</span>
</code></pre></div>
<hr>

<p>Let&#39;s define our <code>main</code> function.</p>
<div class="highlight"><pre><code class="rust language-rust" data-lang="rust"><span class="c1">// src/main.rs</span>
<span class="p">...</span>

<span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">code</span> <span class="o">=</span> <span class="p">[</span>
    <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x89</span><span class="p">,</span> <span class="mh">0xf8</span><span class="p">,</span>       <span class="c1">// mov %rdi, %rax</span>
    <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x83</span><span class="p">,</span> <span class="mh">0xc0</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="c1">// add $4, %rax</span>
    <span class="mh">0xc3</span>                    <span class="c1">// ret</span>
  <span class="p">];</span>

  <span class="k">let</span> <span class="n">region</span> <span class="o">=</span> <span class="k">match</span> <span class="n">safe</span><span class="o">::</span><span class="n">mmap</span><span class="p">(</span><span class="n">code</span><span class="p">.</span><span class="n">len</span><span class="p">()</span> <span class="k">as</span> <span class="k">u64</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Ok</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">r</span><span class="p">,</span>
      <span class="n">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">fail</span><span class="o">!</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
  <span class="p">};</span>

  <span class="k">type</span> <span class="n">AddFourFn</span> <span class="o">=</span> <span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="k">fn</span><span class="p">(</span><span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">int</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">Add</span> <span class="o">=</span> <span class="n">jit_func</span><span class="o">::&lt;</span><span class="n">AddFourFn</span><span class="o">&gt;</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">code</span><span class="p">);</span>
  <span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Add(4): {}&quot;</span><span class="p">,</span> <span class="n">Add</span><span class="p">(</span><span class="m">4</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
<p>Again, this was a previous example on using the safe mmap function. We&#39;ll assign the new <code>MappedRegion</code> to <code>region</code>.</p>
<div class="highlight"><pre><code class="rust language-rust" data-lang="rust"><span class="c1">// src/main.rs</span>
<span class="p">...</span>
<span class="k">let</span> <span class="n">region</span> <span class="o">=</span> <span class="k">match</span> <span class="n">safe</span><span class="o">::</span><span class="n">mmap</span><span class="p">(</span><span class="n">contents</span><span class="p">.</span><span class="n">len</span><span class="p">()</span> <span class="k">as</span> <span class="k">u64</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Ok</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">r</span><span class="p">,</span>
    <span class="n">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">fail</span><span class="o">!</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
<span class="p">};</span>
<span class="p">...</span>
</code></pre></div>
<p>Rust is extremely good at interoperating with other runtimes, such as C. We&#39;ll define a basic function pointer that takes an <code>int</code> and returns an <code>int</code>. We&#39;re also defining this as a type, to make it easier to use.</p>
<div class="highlight"><pre><code class="rust language-rust" data-lang="rust"><span class="c1">// src/main.rs</span>
<span class="p">...</span>
<span class="k">type</span> <span class="n">AddFourFn</span> <span class="o">=</span> <span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="k">fn</span><span class="p">(</span><span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">int</span><span class="p">;</span>
<span class="p">...</span>
</code></pre></div>
<p>This is the magic bit. We haven&#39;t defined this function yet; we&#39;ll get to that next.</p>

<p>We&#39;ll pass our function pointer as a generic argument, along with the <code>code</code> (our encoded x86 instructions), and <code>region</code> which hold our mmapped memory block.</p>
<div class="highlight"><pre><code class="rust language-rust" data-lang="rust"><span class="c1">// src/main.rs</span>
<span class="p">...</span>
<span class="k">let</span> <span class="n">Add</span> <span class="o">=</span> <span class="n">jit_func</span><span class="o">::&lt;</span><span class="n">AddFourFn</span><span class="o">&gt;</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">code</span><span class="p">);</span>
<span class="p">...</span>
</code></pre></div>
<p>Call the awesome function:</p>
<div class="highlight"><pre><code class="rust language-rust" data-lang="rust"><span class="c1">// src/main.rs</span>
<span class="p">...</span>
<span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Add(4): {}&quot;</span><span class="p">,</span> <span class="n">Add</span><span class="p">(</span><span class="m">4</span><span class="p">));</span> <span class="c1">// Add(4): 8</span>
<span class="p">...</span>
</code></pre></div>
<hr>

<p>Let&#39;s define the <code>jit_func</code> function. This should be placed right before the <code>main</code> function.</p>
<div class="highlight"><pre><code class="rust language-rust" data-lang="rust"><span class="c1">// src/main.rs</span>
<span class="p">...</span>
<span class="k">fn</span> <span class="n">jit_func</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">region</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">MappedRegion</span><span class="p">,</span> <span class="n">contents</span><span class="o">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="k">u8</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="n">safe</span><span class="o">::</span><span class="n">memcpy</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">contents</span><span class="p">);</span>
        <span class="n">safe</span><span class="o">::</span><span class="n">mprotect</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">contents</span><span class="p">);</span>
        <span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">contents</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">()),</span> <span class="o">*</span><span class="n">region</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>
        <span class="n">cast</span><span class="o">::</span><span class="n">transmute</span><span class="p">(</span><span class="n">region</span><span class="p">.</span><span class="n">addr</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{...}</span>
</code></pre></div>
<p>So, the basic steps are:</p>

<ul>
<li><code>safe::memcpy</code>: Copy the instructions into the memory block.</li>
<li><code>safe::mprotect</code> Make the memory read-only, but executable.</li>
<li><code>assert_eq!(*(contents.as_ptr()), *region.addr);</code>: Ensure that the contents of the memory block is <em>exactly</em> the same as our vector.</li>
<li><code>cast::transmute(region.addr)</code>: We need to transform a raw pointer, which points to the beginning of the JIT function, to a C-style function pointer.</li>
</ul>

<p>The <code>cast::transmute(region.addr)</code> will be casted against the specific JIT function type (which is a generic argument <code>T</code>). In this example, it&#39;s a function <code>extern &quot;C&quot; fn(int) -&gt; int</code>.</p>

<hr>

<p>Also, the reason we didn&#39;t put the <code>safe::mmap</code> call within the <code>jit_func</code> function is because we&#39;d run into a segfault error while trying to execute our JITed function. That&#39;s because as soon as <code>jit_func</code> returns, our mmapped memory will be deallocated because the <code>MappedRegion</code> unique pointer will have gone out of scope.</p>

<p>A better way would be to split the functionality into many steps.</p>
<div class="highlight"><pre><code class="rust language-rust" data-lang="rust"><span class="k">type</span> <span class="n">AddFourFn</span> <span class="o">=</span> <span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="k">fn</span><span class="p">(</span><span class="k">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">int</span><span class="p">;</span>
<span class="k">let</span> <span class="n">add</span> <span class="o">=</span> <span class="n">jit</span><span class="o">::</span><span class="n">func</span><span class="o">::&lt;</span><span class="n">AddFourFn</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">add</span><span class="p">.</span><span class="n">emit_mov</span><span class="p">(</span><span class="s">&quot;%rdi&quot;</span><span class="p">,</span> <span class="s">&quot;%rax&quot;</span><span class="p">);</span>
<span class="n">add</span><span class="p">.</span><span class="n">emit_add</span><span class="p">(</span><span class="m">4</span><span class="p">,</span> <span class="s">&quot;%rax&quot;</span><span class="p">);</span>
<span class="n">add</span><span class="p">.</span><span class="n">emit_ret</span><span class="p">();</span>
<span class="k">let</span> <span class="n">addFn</span> <span class="o">=</span> <span class="n">add</span><span class="p">.</span><span class="n">getFunction</span><span class="p">();</span>
<span class="n">addFn</span><span class="p">(</span><span class="m">4</span><span class="p">);</span>
</code></pre></div>
<p>This would include having instruction encoding for various architectures and such.</p>

<p>Or, you could just use LLVM or LibJit. But, it&#39;s a good educational experience to learning, understanding, and implementing a JIT compiler.</p>

<p>You can view the <a href="https://github.com/TheHydroImpulse/jiter">full source code on Github.</a></p>

<hr>

<p><a href="http://twitter.com/TheHydroImpulse">Follow me on Twitter</a></p>

<p><a href="http://github.com/TheHydroImpulse">Github</a></p>

</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/2014/01/31/llvm-with-rust/">
            Using LLVM From Within Rust
            <small>31 Jan 2014</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

<div class="comments">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'hydrocodedesign'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

      </div>
    </div>

  </body>
</html>
